\documentclass[a4paper,12pt]{article}
%\VignetteIndexEntry{Manual for the casper library}
%\VignettePackage{casper}



\usepackage{amsmath}    % need for subequations
\usepackage{amssymb}    %useful mathematical symbols
\usepackage{bm}         %needed for bold greek letters and math symbols
\usepackage{graphicx}   % need for PS figures
%\usepackage{verbatim}   % useful for program listings
%\usepackage{color}      % use if color is used in text
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
\usepackage{natbib}    %number and author-year style referencing
%\usepackage{epsf} 
%\usepackage{lscape} 
%\bibpunct{(}{)}{;}{a}{,}{,}



\pagestyle{empty} % use if page numbers not wanted

\begin{document}

\title{Manual for the R \texttt{casper} package}
\author{David Rossell \\
\small{Bioinformatics \& Biostatistics Unit} \\
\small{IRB Barcelona}}
\date{}  %comment to include current date

\maketitle


\section{Introduction}
\label{sec:intro}

The package \texttt{casper} implements statistical methodology to infer
gene alternative splicing patterns from next-generation sequencing data \citep{rossell:2010}.
Although functions for single-end data are available, the emphasis is on
paired-end data.

In Section \ref{sec:quant_known} we show how to quantify known splicing variants.
In Section \ref{sec:classes} we briefly describe some of the classes defined in
package \texttt{casper} to store alternative splicing information.


\section{Quantifying known splicing variants}
\label{sec:quant_known}

\subsection{Obtaining the alternative splicing information}

The first thing to do is to obtain the alternative splicing information for all genes of interest,
and format it into an object that \texttt{casper} can work with.
To facilitate use, 
we pre-computed the UCSC splicing information for all human genes for genome versions hg18 and hg19.
The information is stored in an object of class \texttt{GWcodedVariant},
and can be loaded using the \texttt{data} function.
Information for any given chromosome or gene can be easily accessed, as illustrated below for gene ABCG1.

<<codedVariant1>>=
library(casper)
data(hg19GWcodedVariant)
hg19GWcodedVariant
hg19GWcodedVariant[['chr21']]
hg19GWcodedVariant[['chr21']][['ABCG1']]
@ 

It is also possible to create the object for other organisms or genome versions.
We provide a function \texttt{getRefflat} which obtains the refflat for the selected organism
from UCSC and stores it into a \texttt{data.frame}.
Once the refflat table is obtained, the function \texttt{Refflat2RangedDataList}
converts it into a \texttt{RangedDataList} (see package \texttt{IRanges} for details).
To work with data from outside UCSC one can simply generate a \texttt{data.frame} with
the same format as that returned by \texttt{getRefflat},
or directly generate a \texttt{RangedDataList} object.
The last step is to code the information in the \texttt{RangedDataList} into
the format required by \texttt{casper} using the information \texttt{codesVariant}.
Below we show some sample code, in which we select only chromosomes 21 and 22
for illustration purposes.

<<codedVariant2>>=
hg19 <- getRefflat(genome='hg19')
hg19 <- hg19[hg19$chrom %in% c('chr21','chr22'),]
names(hg19)
hg19SpliceVar <- Refflat2RangedDataList(hg19, organism='hg19', mc.cores=4)
hg19SpliceVar
hg19SpliceVar[['chr21']]
hg19GWcodedVariant <- codesVariant(hg19SpliceVar, mc.cores=4, excludeAliased=FALSE)
@ 

The argument \texttt{excludeAliased} can be used to exclude from the analysis
exons of a gene which are overlapping
with those from some other gene.
In this example we choose not to exclude them.

\subsection{Formatting the experimental data}

\texttt{casper} takes into account paired end read information.
Currently, paired end reads should be structured in a \texttt{RangedData} object.
The start and end of each range correspond to the start of the left-most read
and the end of the right-most read, respectively.
We load the example data \texttt{peSeqTestData} included with \texttt{casper}.

<<loadData>>=
data(peSeqTestData)
head(peSeqTestData,n=8)
readLength <- 38
m <- 26
@ 

The first row indicates two paired reads aligned to chromosome 21.
The left-most read started at position 45173496
and the right-most pair ended at position 45175620.

In this experiment the read length was 38, and the software used to map
the reads required required at least \texttt{m=26} consecutive bases on one side
of a splicing junction to be able to map the read.

\subsection{Model fit}

That is, reads spanning less than 26 bases on each side of an exon boundary were not been mapped.
We use the function \texttt{fragLength} to estimate the fragment length distribution
from the data.
Figure \ref{fig:fragLength} shows the estimated distribution of fragment lengths,
measured from start of left-most read to start of right-most read
(i.e. the width of the ranges in \texttt{peSeqTestData} 
with both ends falling on the same exon
minus \texttt{readLength}).

<<label=fragLength,include=FALSE>>=
lambdaProbs <- fragLength(peSeqTestData, distrib='nonpar', maxFragLength=400, readLength=readLength)
plot(as.numeric(names(lambdaProbs)),lambdaProbs,type='l',xlab='Fragment length')
@ 

\setkeys{Gin}{width=0.5\textwidth} 
\begin{figure}
\begin{center}
<<label=fragLength,fig=TRUE,echo=FALSE>>=
<<fragLength>>  
@
\end{center}
\caption{Fragment length distribution}
\label{fig:fragLength}
\end{figure}

The two final pieces of information required for the model fit are the
exon coverage matrix and the exon coverage profiles,
which can be computed with the functions
\texttt{exonCovMatrix} and \texttt{exonCovProfiles}.
The position $(i,j)$ of the exon coverage matrix counts the number of reads starting at exon $i$
and ending on exon $j$.
Position $(i,j)$ of the exon coverage profile for a given splicing variant gives the expected coverage matrix.

<<exonCoverage>>=
ecm1 <- exonCovMatrix(x=peSeqTestData, exons=hg19GWcodedVariant, readLength=readLength, m=m, mc.cores=2)
ecp <- exonCovProfiles(exons=hg19GWcodedVariant, lambdaProbs=lambdaProbs, readLength=readLength, m=m, mc.cores=2)
@ 

Notice that while the exon coverage matrix needs to be re-computed for each dataset,
the exon coverage profiles do not change as long as the fragment length distribution (\texttt{lambdaProbs} argument)
does not change.
Therefore, if one has several samples where it is reasonable to assume that the fragment length distribution
is the same for each of them, it is enough to compute the exon coverage profiles once.
This is convenient, as currently this is one of the more computer-intensive steps.

The model is fit with the \texttt{qasper} function, giving the exon coverage matrix
and profiles as input, as well as the (coded) splicing variants (\texttt{cVariant})
and the fragment length distribution (\texttt{lambdaProbs}).
A separate model is fit for each gene of interest, and the results are stored in a single
object of class \texttt{GWqasper} (Genome-Wide qasper).
It is possible to select the model fits for a given chromosome or gene by usual subsetting,
as shown below for chromosome 21 and gene ABCG1.

<<qasperFit>>=
qasper1 <- qasper(exonCovMat=ecm1, exonCovProf=ecp, cVariant=hg19GWcodedVariant, mc.cores=2, excludeSingleVariant=FALSE, lambdaProbs=lambdaProbs)
qasper1
qasper1[['chr21']]
qasper1[['chr21']][['ABCG1']]
@ 

To obtain the estimated abundance of each splicing variant one can use the function \texttt{postmode}.
This function returns the estimates for all genes of interest as an \texttt{ExpressionSet}.

<<qasperEstimates>>=
abundEstim <- postmode(qasper1)
head(exprs(abundEstim),n=10)
@ 

Notice that \texttt{qasper} estimates relative expression levels,
i.e. the proportion of transcripts of a give gene originating from each variant.
In our example, gene ABCG1 has 6 variants. The estimated abundance for variant 1 is
0.323, for variant 2 it is 0.257 etc.
Gene ADAMTS1 has a single variant, and therefore all transcripts are originating from
this variant. Similary for gene ADAMTS5.

\subsection{Plots and model diagnostics}

The \texttt{plot} function produces a plot with the splicing variants
and their estimated abundances.

<<label=qasperBarplots,include=FALSE>>=
plot(qasper1[['chr21']][['ABCG1']])
@ 

\setkeys{Gin}{width=0.5\textwidth} 
\begin{figure}
\begin{center}
<<label=qasperBarplots,fig=TRUE,echo=FALSE>>=
<<qasperBarplots>>
@ 
\end{center}
\caption{Estimated abundances for gene ABCG1}
\label{fig:qasperBarplots}
\end{figure}

The function \texttt{rangesPlots} allows us to examine the reads
and the gene structure simultaneously.
Here we illustrate two versions of the plot,
one presenting a single diagram for the gene containing all of its exons,
and the other presenting the different isoforms.

<<label=qasperRangesPlots1,include=FALSE>>=
myexons <- exons(hg19GWcodedVariant[['chr21']])['ABCG1']
hg19GWcodedVariant[['chr21']][['ABCG1']]
rangesPlot(peSeqTestData,gene= ranges(myexons))
@ 

<<label=qasperRangesPlots2,include=FALSE>>=
myvariants <- variants(hg19GWcodedVariant[['chr21']][['ABCG1']])
rangesPlot(peSeqTestData,gene= myvariants)
@ 

\setkeys{Gin}{width=0.5\textwidth} 
\begin{figure}
\begin{center}
<<label=qasperRangesPlots1,fig=TRUE,echo=FALSE>>=
<<qasperRangesPlots1>>
@
\end{center}
\caption{Observed reads for gene ABCG1. Black lines indicate long reads (typically spanning several exons).
Grey lines indicate short reads (typically falling in a single exon). The gray line on the bottom half of the plot
indicates the coverage at each position.}
\label{fig:qasperBarplots}
\end{figure}

\setkeys{Gin}{width=0.5\textwidth} 
\begin{figure}
\begin{center}
<<label=qasperRangesPlots2,fig=TRUE,echo=FALSE>>=
<<qasperRangesPlots2>>
@
\end{center}
\caption{Observed reads for gene ABCG1, showing all splicing variants. 
Black lines indicate long reads (typically spanning several exons).
Grey lines indicate short reads (typically falling in a single exon). The gray line on the bottom half of the plot
indicates the coverage at each position.}
\label{fig:qasperBarplots}
\end{figure}

Finally, it is possible to check the model validity by computing residuals.
For example, for gene ABCG1 only one residual is statistically significant.
It indicates that the number of reads starting and ending in the last exon
is higher than what the model predicts. 
That is, there seems to be a 3' end bias.
This should not be a major issue for this gene,
as all variants have that exon.
If only some variants had the 3' exon,
this would cause some biases.
This can be presented by appropriately specifying the
\texttt{excludeRanges} argument in the call to \texttt{qasper}.
A residual plot can be obtained by calling the function \texttt{residualPlot}.

<<residualPlots>>=
getResiduals(qasper1[['chr21']][['ABCG1']])
@ 

\section{Classes defined in casper}
\label{sec:classes}

The package \texttt{casper} defines some new classes useful for storing splicing variant information
and exon coverage matrices.

\subsection{Classes for splicing variants}
\label{ssec:splicingvar_classes}

Splicing variant information for a single gene is stored in \texttt{RangedData} objects defined
in the \texttt{IRanges} package.
Exon start and end positions are stored in the \texttt{ranges} component,
and each variant defines a separate space.
Similarly, splicing variant information for all genes in a single chromosome is stored
in a \texttt{RangedDataList} object, where each element in the list corresponds to a different gene.
To store genome-wide splicing variants (i.e. across all chromosome), \texttt{casper} defines
the class \texttt{GWSpliceVar} which has a slot \texttt{Variant} with the splicing variants
and a slot \texttt{organism} indicating what organism the variants correspond to (e.g. hg19, dm3, etc.).

These classes define exons in terms of their start and end chromosomal positions,
and allow exons from different splicing variants to overlap with each other.
To be able to assign reads to splicing variants, it is convenient to divide the
partially overlapping exons into smaller exons with either do not overlap,
or overlap completely. This can be achieved with the
function \texttt{codesVariant}.
At the gene level, splicing variants without partially overlapping exons are stored
in objects of class \texttt{codedVariant}.
\texttt{codedVariant} objects have slots:

\begin{itemize}
\item \texttt{exons}: \texttt{IRanges} object with sub-divided exons
\item \texttt{sVariant}: list with the i$^{th}$ variant indicating the exons contained in variant i.
\item \texttt{excludeExons}: matrix indicating if any exons where removed. Exons are removed 
if the argument \texttt{excludeExons} is specified when calling \texttt{codesVariant}.
\end{itemize}
Notice that slot \texttt{exons} contains exons from all splicing variants.
To view the start and end positions of exons for a variant \texttt{i},
use \texttt{exons[sVariant[i]]}.

\texttt{codedVariantList} allows storing splicing information for all genes in a chromosome,
and \texttt{GWcodedVariant} for all chromosomes.
Additionally, \texttt{codedVariantList} stores the names of genes which were excluded due to all
of their exons overlapping with other genes.

In summary, the classes for storing splicing variants are:
\begin{itemize}
\item Splicing variants for a single gene: \texttt{RangedData}
\item Splicing variants for all genes in a chromosome: \texttt{RangedDataList}
\item Splicing variants genome-wide: \texttt{GWSpliceVar}
\item Splicing variants for a single gene, no partial overlaps between exons: \texttt{codedVariant}
\item Splicing variants for all genes in a chromosome, no partial overlaps between exons: \texttt{codedVariantList}
\item Splicing variants genome-wide, no partial overlaps between exons: \texttt{GWcodedVariant}
\end{itemize}

\subsection{Classes for exon coverage}
\label{ssec:exoncov_classes}

Following the terminology in \cite{rossell:2010},
we define as {\it exon coverage matrix} the matrix
which stores in its $(i,j)$ position the number of reads with their
left end starting in exon $i$ and their right read ending in exon $j$.
These matrices are the basis for splicing variant quantification.
Typically, exon coverage matrices are very sparse, with most elements being
equal to zero.
We take advantage of this fact by storing the exon coverage matrix for a single gene
as a sparse matrix of class \texttt{matrix.csr}, as defined in package \texttt{SparseM}.
This lowers substantially the memory requirements, and speeds up computations.

In order to store exon coverage matrices for all genes in a single chromosome,
\texttt{casper} defines the class \texttt{matrixCsrList}.
We also defined \texttt{ecmList}, which additionally to the slot \texttt{coverage} of class \texttt{matrixCsrList}
it has the slot \texttt{notmapped} which is an \texttt{IRanges} object with all the reads for which at least one end
could not be mapped to any known exon. 
Genome-wide \texttt{ecmList} (i.e. across all chromosomes) are stored
as \texttt{GWecm} objects.

\bibliographystyle{plainnat}
\bibliography{references} 

\end{document}
